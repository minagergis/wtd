/**
 * Excel Comparison Tool - Position-Based Comparison
 * Compares sheets using row + column index (not key columns)
 * Displays results in Excel-like grid view with color-coded cells
 */

// Global state
const state = {
    file1: null,
    file2: null,
    workbook1: null,
    workbook2: null,
    comparisonData: null,
    currentView: 'sidebyside',
    displayLimit: 1000, // Only display first 1000 rows
    worker: null
};

//Initialize on DOM load
document.addEventListener('DOMContentLoaded', () => {
    initializeUploadBoxes();
    initializeConfigSection();
    initializeViewToggle();
    initializeExport();
});

/**
 * File Upload Handling
 */
function initializeUploadBoxes() {
    [1, 2].forEach(num => {
        const uploadBox = document.getElementById(`upload-box-${num}`);
        const fileInput = document.getElementById(`file-${num}`);

        // Click to select file
        uploadBox.addEventListener('click', () => fileInput.click());

        // File input change
        fileInput.addEventListener('change', (e) => {
            handleFileSelect(e.target.files[0], num);
        });

        // Drag and drop
        uploadBox.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadBox.classList.add('dragover');
        });

        uploadBox.addEventListener('dragleave', () => {
            uploadBox.classList.remove('dragover');
        });

        uploadBox.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadBox.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && (file.name.endsWith('.xlsx') || file.name.endsWith('.xls'))) {
                handleFileSelect(file, num);
            } else {
                alert('Please drop a valid Excel file (.xlsx or .xls)');
            }
        });
    });
}

/**
 * Handle file selection and parsing
 */
async function handleFileSelect(file, fileNum) {
    if (!file) return;

    showProgress('Reading Excel file...');

    try {
        const data = await readFileAsArrayBuffer(file);
        const workbook = XLSX.read(data, { type: 'array' });

        // Store in state
        if (fileNum === 1) {
            state.file1 = file;
            state.workbook1 = workbook;
        } else {
            state.file2 = file;
            state.workbook2 = workbook;
        }

        // Update UI
        updateFileInfo(file, workbook, fileNum);
        populateSheetSelect(workbook, fileNum);

        // Show config section if both files uploaded
        if (state.file1 && state.file2) {
            document.getElementById('config-section').classList.add('visible');
            checkCompareButtonState();
        }

        hideProgress();
    } catch (error) {
        hideProgress();
        alert(`Error reading file: ${error.message}`);
    }
}

/**
 * Read file as ArrayBuffer
 */
function readFileAsArrayBuffer(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = (e) => reject(e);
        reader.readAsArrayBuffer(file);
    });
}

/**
 * Update file information display
 */
function updateFileInfo(file, workbook, fileNum) {
    const uploadBox = document.getElementById(`upload-box-${fileNum}`);
    const fileInfo = document.getElementById(`file-info-${fileNum}`);

    uploadBox.classList.add('uploaded');

    const fileSize = (file.size / 1024).toFixed(2);
    const sheetCount = workbook.SheetNames.length;

    fileInfo.innerHTML = `
        <strong>✓ ${file.name}</strong><br>
        Size: ${fileSize} KB | Sheets: ${sheetCount}
    `;
    fileInfo.classList.add('visible');
}

/**
 * Populate sheet selection dropdowns
 */
function populateSheetSelect(workbook, fileNum) {
    const select = document.getElementById(`sheet-select-${fileNum}`);
    select.innerHTML = '<option value="">Select a sheet...</option>';

    workbook.SheetNames.forEach(sheetName => {
        const option = document.createElement('option');
        option.value = sheetName;
        option.textContent = sheetName;
        select.appendChild(option);
    });
}

/**
 * Configuration Section
 */
function initializeConfigSection() {
    const compareBtn = document.getElementById('compare-btn');
    const sheet1Select = document.getElementById('sheet-select-1');
    const sheet2Select = document.getElementById('sheet-select-2');

    // Enable compare button when both sheets selected
    [sheet1Select, sheet2Select].forEach(element => {
        element.addEventListener('change', checkCompareButtonState);
    });

    // Compare button click
    compareBtn.addEventListener('click', performComparison);
}

/**
 * Check if compare button should be enabled
 */
function checkCompareButtonState() {
    const sheet1 = document.getElementById('sheet-select-1').value;
    const sheet2 = document.getElementById('sheet-select-2').value;

    const compareBtn = document.getElementById('compare-btn');
    compareBtn.disabled = !(sheet1 && sheet2);
}

/**
 * Main comparison function - Position-Based with Web Worker
 */
async function performComparison() {
    showProgress('Preparing comparison...', 'Loading sheet data');

    // Small delay to allow UI to update
    await new Promise(resolve => setTimeout(resolve, 100));

    try {
        // Get selected sheets
        const sheet1Name = document.getElementById('sheet-select-1').value;
        const sheet2Name = document.getElementById('sheet-select-2').value;

        const ws1 = state.workbook1.Sheets[sheet1Name];
        const ws2 = state.workbook2.Sheets[sheet2Name];

        // Convert to 2D array (preserve empty cells)
        const data1 = XLSX.utils.sheet_to_json(ws1, { header: 1, defval: '' });
        const data2 = XLSX.utils.sheet_to_json(ws2, { header: 1, defval: '' });

        // Get key column for matching
        const keyColumn = document.getElementById('key-column').value.trim().toUpperCase();
        const keyColumnIndex = keyColumn ? columnLetterToIndex(keyColumn) : -1;

        // Show row count info
        const totalRows = Math.max(data1.length, data2.length);
        showProgress('Comparing sheets...', `Processing ${totalRows.toLocaleString()} rows by ${keyColumn || 'position'}`);

        // Use key-based or position-based comparison
        let comparisonData;
        if (keyColumnIndex >= 0) {
            // Key-based comparison
            comparisonData = compareSheetsByKey(data1, data2, keyColumnIndex);
            state.comparisonData = comparisonData;
            displayComparison(comparisonData);
        } else {
            // Position-based comparison
            if (totalRows > 100) {
                await compareUsingWorker(data1, data2);
            } else {
                comparisonData = compareSheetsByPosition(data1, data2);
                state.comparisonData = comparisonData;
                displayComparison(comparisonData);
            }
        }

        // Show results section
        document.getElementById('results-section').classList.add('visible');

        // Scroll to results
        document.getElementById('results-section').scrollIntoView({ behavior: 'smooth' });

        hideProgress();
    } catch (error) {
        hideProgress();
        alert(`Error during comparison: ${error.message}`);
        console.error(error);
    }
}

/**
 * Create inline Web Worker from Blob (works with file:// URLs)
 */
function createComparisonWorker() {
    const workerCode = `
        self.onmessage = function(e) {
            const { data1, data2 } = e.data;
            
            try {
                const result = compareSheetsByPosition(data1, data2);
                self.postMessage({ success: true, data: result });
            } catch (error) {
                self.postMessage({ success: false, error: error.message });
            }
        };

        function compareSheetsByPosition(data1, data2) {
            const maxRows = Math.max(data1.length, data2.length);
            const maxCols = Math.max(
                ...data1.map(row => row.length),
                ...data2.map(row => row.length),
                0
            );

            const columns = [];
            for (let i = 0; i < maxCols; i++) {
                columns.push(columnIndexToLetter(i));
            }

            const matrix = [];
            let stats = { total: 0, added: 0, removed: 0, modified: 0 };

            for (let r = 0; r < maxRows; r++) {
                const row = [];
                for (let c = 0; c < maxCols; c++) {
                    const val1 = (data1[r] && data1[r][c] !== undefined) ? String(data1[r][c]) : '';
                    const val2 = (data2[r] && data2[r][c] !== undefined) ? String(data2[r][c]) : '';

                    let type = 'unchanged';
                    if (val1 === '' && val2 !== '') {
                        type = 'added';
                        stats.added++;
                        stats.total++;
                    } else if (val1 !== '' && val2 === '') {
                        type = 'removed';
                        stats.removed++;
                        stats.total++;
                    } else if (val1 !== val2 && val1 !== '' && val2 !== '') {
                        type = 'modified';
                        stats.modified++;
                        stats.total++;
                    }

                    row.push({
                        row: r,
                        col: c,
                        oldValue: val1,
                        newValue: val2,
                        type: type
                    });
                }
                matrix.push(row);
                
                if (r % 100 === 0) {
                    self.postMessage({ 
                        progress: true, 
                        current: r, 
                        total: maxRows,
                        percent: Math.round((r / maxRows) * 100)
                    });
                }
            }

            return {
                matrix,
                columns,
                stats,
                data1,
                data2,
                maxRows,
                maxCols
            };
        }

        function columnIndexToLetter(index) {
            let letter = '';
            while (index >= 0) {
                letter = String.fromCharCode((index % 26) + 65) + letter;
                index = Math.floor(index / 26) - 1;
            }
            return letter;
        }
    `;

    const blob = new Blob([workerCode], { type: 'application/javascript' });
    return new Worker(URL.createObjectURL(blob));
}

/**
 * Compare using Web Worker (non-blocking)
 */
function compareUsingWorker(data1, data2) {
    return new Promise((resolve, reject) => {
        // Create worker from inline code
        if (state.worker) {
            state.worker.terminate();
        }

        try {
            state.worker = createComparisonWorker();
        } catch (error) {
            // Fallback to main thread if worker fails
            console.warn('Web Worker failed, using main thread:', error);
            const comparisonData = compareSheetsByPosition(data1, data2);
            state.comparisonData = comparisonData;
            displayComparison(comparisonData);
            resolve();
            return;
        }

        // Handle messages from worker
        state.worker.onmessage = function (e) {
            if (e.data.progress) {
                // Update progress
                showProgress(
                    'Comparing sheets...',
                    `Processing row ${e.data.current.toLocaleString()} of ${e.data.total.toLocaleString()} (${e.data.percent}%)`
                );
            } else if (e.data.success) {
                // Comparison complete
                state.comparisonData = e.data.data;
                displayComparison(e.data.data);
                state.worker.terminate();
                state.worker = null;
                resolve();
            } else {
                // Error occurred
                state.worker.terminate();
                state.worker = null;
                reject(new Error(e.data.error));
            }
        };

        state.worker.onerror = function (error) {
            console.error('Worker error:', error);
            state.worker.terminate();
            state.worker = null;
            // Fallback to main thread
            const comparisonData = compareSheetsByPosition(data1, data2);
            state.comparisonData = comparisonData;
            displayComparison(comparisonData);
            resolve();
        };

        // Start comparison
        state.worker.postMessage({ data1, data2 });
    });
}

/**
 * Position-based comparison algorithm
 */
function compareSheetsByPosition(data1, data2) {
    // Normalize to max dimensions
    const maxRows = Math.max(data1.length, data2.length);
    const maxCols = Math.max(
        ...data1.map(row => row.length),
        ...data2.map(row => row.length),
        0
    );

    // Generate column headers (A, B, C, ...)
    const columns = [];
    for (let i = 0; i < maxCols; i++) {
        columns.push(columnIndexToLetter(i));
    }

    // Build comparison matrix
    const matrix = [];
    let stats = { total: 0, added: 0, removed: 0, modified: 0 };

    for (let r = 0; r < maxRows; r++) {
        const row = [];
        for (let c = 0; c < maxCols; c++) {
            const val1 = (data1[r] && data1[r][c] !== undefined) ? String(data1[r][c]) : '';
            const val2 = (data2[r] && data2[r][c] !== undefined) ? String(data2[r][c]) : '';

            let type = 'unchanged';
            if (val1 === '' && val2 !== '') {
                type = 'added';
                stats.added++;
                stats.total++;
            } else if (val1 !== '' && val2 === '') {
                type = 'removed';
                stats.removed++;
                stats.total++;
            } else if (val1 !== val2 && val1 !== '' && val2 !== '') {
                type = 'modified';
                stats.modified++;
                stats.total++;
            }

            row.push({
                row: r,
                col: c,
                oldValue: val1,
                newValue: val2,
                type: type
            });
        }
        matrix.push(row);
    }

    return {
        matrix,
        columns,
        stats,
        data1,
        data2,
        maxRows,
        maxCols
    };
}

/**
 * Convert column index to letter (0 = A, 25 = Z, 26 = AA, etc.)
 */
function columnIndexToLetter(index) {
    let letter = '';
    while (index >= 0) {
        letter = String.fromCharCode((index % 26) + 65) + letter;
        index = Math.floor(index / 26) - 1;
    }
    return letter;
}

/**
 * Display comparison results
 */
function displayComparison(comparisonData) {
    // Update statistics
    document.getElementById('stat-total').textContent = comparisonData.stats.total;
    document.getElementById('stat-added').textContent = comparisonData.stats.added;
    document.getElementById('stat-removed').textContent = comparisonData.stats.removed;
    document.getElementById('stat-modified').textContent = comparisonData.stats.modified;

    // Show unit-level statistics if available
    if (comparisonData.unitStats) {
        console.log('Unit-level Statistics:');
        comparisonData.unitStats.forEach((stats, unit) => {
            console.log(`${unit}: Added=${stats.added}, Removed=${stats.removed}, Modified=${stats.modified}, Unchanged=${stats.unchanged}`);
        });
    }

    // Render grid based on current view
    renderGrid(comparisonData, state.currentView);
}

/**
 * Render Excel-like grid - Single combined view
 */
function renderGrid(comparisonData, viewMode) {
    const container = document.getElementById('excel-grid-container');
    container.innerHTML = '';

    // Always render single combined view
    renderCombinedView(container, comparisonData);
}

/**
 * Render combined view with old/new values and status
 */
function renderCombinedView(container, data) {
    const wrapper = document.createElement('div');
    wrapper.className = 'grid-wrapper';
    wrapper.style.justifyContent = 'center';

    const panel = createCombinedPanel('Comparison Results', data.columns, data.matrix);
    wrapper.appendChild(panel);

    container.appendChild(wrapper);
}

/**
 * Create sheet panel with row limiting
 */
function createSheetPanel(title, sheetData, columns, matrix, mode) {
    const panel = document.createElement('div');
    panel.className = 'sheet-panel';

    const titleDiv = document.createElement('div');
    titleDiv.className = 'sheet-title';

    const totalRows = matrix.length;
    const displayRows = Math.min(totalRows, state.displayLimit);

    titleDiv.innerHTML = `${title} <span style="font-size: 0.9em; opacity: 0.8;">(showing ${displayRows.toLocaleString()} of ${totalRows.toLocaleString()} rows)</span>`;
    panel.appendChild(titleDiv);

    const table = document.createElement('table');
    table.className = 'excel-table';

    // Create header row
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');

    // Empty corner cell
    const cornerCell = document.createElement('th');
    cornerCell.className = 'row-header';
    headerRow.appendChild(cornerCell);

    // Column headers (A, B, C, ...)
    columns.forEach(col => {
        const th = document.createElement('th');
        th.textContent = col;
        headerRow.appendChild(th);
    });

    thead.appendChild(headerRow);
    table.appendChild(thead);

    // Create body rows - ONLY RENDER displayLimit rows
    const tbody = document.createElement('tbody');

    // Use chunked rendering for better performance
    renderRowsChunked(tbody, matrix, columns, mode, 0, displayRows);

    table.appendChild(tbody);
    panel.appendChild(table);

    // Add "Load More" button if there are more rows
    if (totalRows > state.displayLimit) {
        const loadMoreBtn = document.createElement('button');
        loadMoreBtn.className = 'btn btn-secondary';
        loadMoreBtn.style.marginTop = '1rem';
        loadMoreBtn.textContent = `Load More Rows (${(totalRows - displayRows).toLocaleString()} remaining)`;
        loadMoreBtn.onclick = () => {
            state.displayLimit += 1000;
            renderGrid(state.comparisonData, state.currentView);
        };
        panel.appendChild(loadMoreBtn);
    }

    return panel;
}

/**
 * Render rows in chunks to avoid blocking UI
 */
function renderRowsChunked(tbody, matrix, columns, mode, startRow, endRow) {
    const chunkSize = 50;
    let currentRow = startRow;

    function renderChunk() {
        const chunkEnd = Math.min(currentRow + chunkSize, endRow);
        const fragment = document.createDocumentFragment();

        for (let r = currentRow; r < chunkEnd; r++) {
            const tr = document.createElement('tr');

            // Row header
            const rowHeader = document.createElement('td');
            rowHeader.className = 'row-header';
            rowHeader.textContent = r + 1;
            tr.appendChild(rowHeader);

            // Data cells
            for (let c = 0; c < matrix[r].length; c++) {
                const cellData = matrix[r][c];
                const td = document.createElement('td');

                // Determine value to show
                let displayValue = '';
                if (mode === 'original') {
                    displayValue = cellData.oldValue;
                } else {
                    displayValue = cellData.newValue;
                }

                td.textContent = displayValue;

                // Apply color coding based on change type
                if (cellData.type !== 'unchanged') {
                    td.classList.add(`cell-${cellData.type}`);

                    // Store data for tooltip
                    td.dataset.cellData = JSON.stringify(cellData);

                    // Add tooltip on hover (lazy)
                    td.addEventListener('mouseenter', showTooltipLazy);
                }

                tr.appendChild(td);
            }

            fragment.appendChild(tr);
        }

        tbody.appendChild(fragment);

        currentRow = chunkEnd;
        if (currentRow < endRow) {
            requestAnimationFrame(renderChunk);
        }
    }

    renderChunk();
}

/**
 * Show tooltip lazily (only create when needed)
 */
function showTooltipLazy(e) {
    const td = e.currentTarget;

    // Check if tooltip already exists
    if (td.querySelector('.cell-tooltip')) return;

    const cellData = JSON.parse(td.dataset.cellData);
    const tooltip = createTooltip(cellData);
    td.appendChild(tooltip);
    positionTooltip(tooltip, e);
}

/**
 * Create tooltip for cell
 */
function createTooltip(cellData) {
    const tooltip = document.createElement('div');
    tooltip.className = 'cell-tooltip';

    const typeLabel = cellData.type.charAt(0).toUpperCase() + cellData.type.slice(1);

    tooltip.innerHTML = `
        <div class="tooltip-row">
            <span class="tooltip-label">Change Type:</span>
            <span class="tooltip-value">${typeLabel}</span>
        </div>
        <div class="tooltip-row">
            <span class="tooltip-label">Position:</span>
            <span class="tooltip-value">Row ${cellData.row + 1}, Col ${columnIndexToLetter(cellData.col)}</span>
        </div>
        <div class="tooltip-row">
            <span class="tooltip-label">Original:</span>
            <span class="tooltip-value">${escapeHtml(cellData.oldValue) || '(empty)'}</span>
        </div>
        <div class="tooltip-row">
            <span class="tooltip-label">New:</span>
            <span class="tooltip-value">${escapeHtml(cellData.newValue) || '(empty)'}</span>
        </div>
    `;

    return tooltip;
}

/**
 * Position tooltip
 */
function positionTooltip(tooltip, event) {
    const rect = event.target.getBoundingClientRect();
    tooltip.style.position = 'fixed';
    tooltip.style.left = rect.right + 10 + 'px';
    tooltip.style.top = rect.top + 'px';
}

/**
 * Escape HTML
 */
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

/**
 * View toggle functionality
 */
function initializeViewToggle() {
    const toggleButtons = document.querySelectorAll('.view-toggle .btn-filter');

    toggleButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            // Update active state
            toggleButtons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Switch view
            const view = btn.dataset.view;
            state.currentView = view;

            if (state.comparisonData) {
                renderGrid(state.comparisonData, view);
            }
        });
    });
}

/**
 * Export functionality
 */
function initializeExport() {
    document.getElementById('export-excel').addEventListener('click', exportToExcel);
}

/**
 * Export to Excel with color coding
 */
function exportToExcel() {
    if (!state.comparisonData) {
        alert('No comparison data to export');
        return;
    }

    showProgress('Generating Excel file with colors...');

    setTimeout(() => {
        try {
            const data = state.comparisonData;
            const wb = XLSX.utils.book_new();

            // Create worksheet from matrix
            const wsData = [];

            // Header row
            const headerRow = ['', ...data.columns];
            wsData.push(headerRow);

            // Data rows
            for (let r = 0; r < data.matrix.length; r++) {
                const row = [r + 1]; // Row number
                for (let c = 0; c < data.matrix[r].length; c++) {
                    row.push(data.matrix[r][c].newValue);
                }
                wsData.push(row);
            }

            const ws = XLSX.utils.aoa_to_sheet(wsData);

            // Apply cell styles (colors)
            if (!ws['!rows']) ws['!rows'] = [];
            if (!ws['!cols']) ws['!cols'] = [];

            // Set column widths
            ws['!cols'] = data.columns.map(() => ({ wch: 15 }));

            // Apply colors to cells
            for (let r = 0; r < data.matrix.length; r++) {
                for (let c = 0; c < data.matrix[r].length; c++) {
                    const cellData = data.matrix[r][c];
                    const cellAddress = XLSX.utils.encode_cell({ r: r + 1, c: c + 1 }); // +1 for header

                    if (cellData.type !== 'unchanged' && ws[cellAddress]) {
                        // Note: SheetJS free version has limited style support
                        // This adds a comment instead of direct cell coloring
                        if (cellData.type === 'added') {
                            ws[cellAddress].c = ws[cellAddress].c || [];
                            ws[cellAddress].c.push({ a: 'System', t: 'Added: ' + cellData.newValue });
                        } else if (cellData.type === 'removed') {
                            ws[cellAddress].c = ws[cellAddress].c || [];
                            ws[cellAddress].c.push({ a: 'System', t: 'Removed: ' + cellData.oldValue });
                        } else if (cellData.type === 'modified') {
                            ws[cellAddress].c = ws[cellAddress].c || [];
                            ws[cellAddress].c.push({ a: 'System', t: `Changed from "${cellData.oldValue}" to "${cellData.newValue}"` });
                        }
                    }
                }
            }

            XLSX.utils.book_append_sheet(wb, ws, 'Comparison');

            // Generate file
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            XLSX.writeFile(wb, `Sheet_Comparison_${timestamp}.xlsx`);

            hideProgress();
        } catch (error) {
            hideProgress();
            alert(`Error exporting to Excel: ${error.message}`);
        }
    }, 100);
}

/**
 * Progress overlay functions
 */
function showProgress(text, detail = '') {
    const overlay = document.getElementById('progress-overlay');
    const progressText = document.querySelector('.progress-text');
    const progressDetail = document.getElementById('progress-detail');

    progressText.textContent = text;
    progressDetail.textContent = detail;
    overlay.classList.add('visible');
}

function hideProgress() {
    const overlay = document.getElementById('progress-overlay');
    overlay.classList.remove('visible');
}
/**
 * Create combined panel with old/new values and status
 */
function createCombinedPanel(title, columns, matrix) {
    const panel = document.createElement('div');
    panel.className = 'sheet-panel';
    panel.style.maxWidth = '100%';

    const titleDiv = document.createElement('div');
    titleDiv.className = 'sheet-title';

    const totalRows = matrix.length;
    const displayRows = Math.min(totalRows, state.displayLimit);

    titleDiv.innerHTML = `${title} <span style="font-size: 0.9em; opacity: 0.8;">(showing ${displayRows.toLocaleString()} of ${totalRows.toLocaleString()} rows)</span>`;
    panel.appendChild(titleDiv);

    const table = document.createElement('table');
    table.className = 'excel-table';

    // Create header row
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');

    // Row number header
    const cornerCell = document.createElement('th');
    cornerCell.className = 'row-header';
    headerRow.appendChild(cornerCell);

    // Column headers (A, B, C, ...) - ONE column per letter
    columns.forEach(col => {
        const th = document.createElement('th');
        th.textContent = col;
        th.style.textAlign = 'center';
        th.style.minWidth = '150px';
        headerRow.appendChild(th);
    });

    thead.appendChild(headerRow);
    table.appendChild(thead);

    // Create body rows
    const tbody = document.createElement('tbody');
    renderCombinedRowsChunked(tbody, matrix, columns, 0, displayRows);

    table.appendChild(tbody);
    panel.appendChild(table);

    // Add "Load More" button if there are more rows
    if (totalRows > state.displayLimit) {
        const loadMoreBtn = document.createElement('button');
        loadMoreBtn.className = 'btn btn-secondary';
        loadMoreBtn.style.marginTop = '1rem';
        loadMoreBtn.textContent = `Load More Rows (${(totalRows - displayRows).toLocaleString()} remaining)`;
        loadMoreBtn.onclick = () => {
            state.displayLimit += 1000;
            renderGrid(state.comparisonData, state.currentView);
        };
        panel.appendChild(loadMoreBtn);
    }

    return panel;
}

/**
 * Render combined rows in chunks (old/new/status format)
 */
function renderCombinedRowsChunked(tbody, matrix, columns, startRow, endRow) {
    const chunkSize = 50;
    let currentRow = startRow;

    function renderChunk() {
        const chunkEnd = Math.min(currentRow + chunkSize, endRow);
        const fragment = document.createDocumentFragment();

        for (let r = currentRow; r < chunkEnd; r++) {
            const tr = document.createElement('tr');

            // Row header
            const rowHeader = document.createElement('td');
            rowHeader.className = 'row-header';
            rowHeader.textContent = r + 1;
            tr.appendChild(rowHeader);

            // For each column, show: Old → New in single cell
            for (let c = 0; c < matrix[r].length; c++) {
                const cellData = matrix[r][c];
                const td = document.createElement('td');
                td.style.minWidth = '150px';
                td.style.padding = '0.75rem';

                const oldVal = cellData.oldValue || '--';
                const newVal = cellData.newValue || '--';

                if (cellData.type === 'unchanged') {
                    // Just show the value
                    td.textContent = cellData.newValue;
                    td.style.color = '#000';
                } else {
                    // Show: Old → New
                    const valuesLine = document.createElement('div');
                    valuesLine.style.fontSize = '0.9rem';
                    valuesLine.style.display = 'flex';
                    valuesLine.style.alignItems = 'center';
                    valuesLine.style.gap = '0.5rem';

                    const oldSpan = document.createElement('span');
                    oldSpan.textContent = oldVal;
                    if (cellData.type === 'removed' || cellData.type === 'modified') {
                        oldSpan.style.textDecoration = 'line-through';
                        oldSpan.style.opacity = '0.7';
                    }
                    oldSpan.style.color = '#666';

                    const arrow = document.createElement('span');
                    arrow.textContent = '→';
                    arrow.style.fontWeight = 'bold';
                    arrow.style.color = '#333';

                    const newSpan = document.createElement('span');
                    newSpan.textContent = newVal;
                    if (cellData.type === 'added' || cellData.type === 'modified') {
                        newSpan.style.fontWeight = '600';
                    }
                    newSpan.style.color = '#000';

                    valuesLine.appendChild(oldSpan);
                    valuesLine.appendChild(arrow);
                    valuesLine.appendChild(newSpan);

                    td.appendChild(valuesLine);

                    // Apply background color based on type
                    if (cellData.type === 'added') {
                        td.style.background = '#e8f5e9';
                        td.style.borderLeft = '3px solid #4caf50';
                    } else if (cellData.type === 'removed') {
                        td.style.background = '#ffebee';
                        td.style.borderLeft = '3px solid #f44336';
                    } else if (cellData.type === 'modified') {
                        td.style.background = '#fffde7';
                        td.style.borderLeft = '3px solid #fbc02d';
                    }

                    // Add tooltip on hover
                    td.dataset.cellData = JSON.stringify(cellData);
                    td.addEventListener('mouseenter', showTooltipLazy);
                }

                tr.appendChild(td);
            }

            fragment.appendChild(tr);
        }

        tbody.appendChild(fragment);

        currentRow = chunkEnd;
        if (currentRow < endRow) {
            requestAnimationFrame(renderChunk);
        }
    }

    renderChunk();
}
/**
 * Key-based comparison logic
 * Matches rows by key column value (e.g., Unit Name in column A)
 */
function compareSheetsByKey(data1, data2, keyColumnIndex) {
    // Build maps of key -> row data
    const map1 = new Map();
    const map2 = new Map();

    // Index all rows by key
    data1.forEach((row, index) => {
        const key = row[keyColumnIndex] || `__EMPTY_ROW_${index}__`;
        map1.set(String(key), { row, index });
    });

    data2.forEach((row, index) => {
        const key = row[keyColumnIndex] || `__EMPTY_ROW_${index}__`;
        map2.set(String(key), { row, index });
    });

    // Get all unique keys
    const allKeys = new Set([...map1.keys(), ...map2.keys()]);

    // Calculate max columns
    const maxCols = Math.max(
        ...data1.map(row => row.length),
        ...data2.map(row => row.length),
        0
    );

    // Generate column headers
    const columns = [];
    for (let i = 0; i < maxCols; i++) {
        columns.push(columnIndexToLetter(i));
    }

    // Build comparison matrix
    const matrix = [];
    const stats = { total: 0, added: 0, removed: 0, modified: 0 };

    allKeys.forEach(key => {
        const entry1 = map1.get(key);
        const entry2 = map2.get(key);

        const row1 = entry1 ? entry1.row : [];
        const row2 = entry2 ? entry2.row : [];

        const rowData = [];

        for (let c = 0; c < maxCols; c++) {
            const val1 = (row1[c] !== undefined) ? String(row1[c]) : '';
            const val2 = (row2[c] !== undefined) ? String(row2[c]) : '';

            let type = 'unchanged';

            if (!entry1 && entry2) {
                // Entire row added
                type = 'added';
                if (val2) {
                    stats.added++;
                    stats.total++;
                }
            } else if (entry1 && !entry2) {
                // Entire row removed
                type = 'removed';
                if (val1) {
                    stats.removed++;
                    stats.total++;
                }
            } else {
                //Both rows exist, compare values
                if (val1 === '' && val2 !== '') {
                    type = 'added';
                    stats.added++;
                    stats.total++;
                } else if (val1 !== '' && val2 === '') {
                    type = 'removed';
                    stats.removed++;
                    stats.total++;
                } else if (val1 !== val2 && val1 !== '' && val2 !== '') {
                    type = 'modified';
                    stats.modified++;
                    stats.total++;
                }
            }

            rowData.push({
                row: matrix.length,
                col: c,
                oldValue: val1,
                newValue: val2,
                type: type,
                key: key
            });
        }

        matrix.push(rowData);
    });

    return {
        matrix,
        columns,
        stats,
        data1,
        data2,
        maxRows: matrix.length,
        maxCols,
        keyColumn: keyColumnIndex
    };
}
/**
 * Convert column letter to index (A=0, B=1, Z=25, AA=26, etc.)
 */
function columnLetterToIndex(letter) {
    let index = 0;
    for (let i = 0; i < letter.length; i++) {
        index = index * 26 + (letter.charCodeAt(i) - 64);
    }
    return index - 1;
}
